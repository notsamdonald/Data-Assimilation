function [t,x, x_k] =  discrete_adj_rk4(lambda_k, rk_steps, h)
% TODO - pass in dxdy instead (actually dxdt)

a = 1

A = [0,0,0,0;
    0.5,0,0,0;
    0,0.5,0,0;
    0,0,1,0];

b = [1/6;1/3;1/3;1/6];

c = [0;0.5;0.5;0];

sigma = 10;
beta = 8/3;
rho = 28;

dxdt = @(x) [sigma*(x(2)-x(1));
                x(1)*(rho-x(3))-x(2);
                x(1)*x(2)-beta*x(3)];

fx = @(x) [-sigma, sigma, 0;
    (rho-x(3)), -1, -x(1);
    x(2), x(1), -beta];

lambda = zeros(3,size(rk_steps,3)+ 1);
lambda = zeros(:,end) = lambda_k;

for k = size(rk_steps,3):-1:1

    a = 1
    u_4 = h*fx(rk_steps(:,4,k)) * (1/6) * lambda_k;
    u_3 = h*fx(rk_steps(:,3,k)) * ((1/3) * lambda_k + u_4);
    u_2 = h*fx(rk_steps(:,2,k)) * ((1/3) * lambda_k + (1/2) * u_3);
    u_1 = h*fx(rk_steps(:,1,k)) * ((1/6) * lambda_k + (1/2) * u_2);

    lambda() = lambda_k + u_1 + u_2 + u_3 + u_4;
    u_1 = x(:,i);
    u_2 = x(:,i) + h * 0.5 * dxdt(k_1);
    u_3 = x(:, i) + h * 0.5 * dxdt(k_2);
    x(:, i+1) = x(:, i) + h*(1/6)*(dxdt(k_1)+2*dxdt(k_2)+ ...
                                    2*dxdt(k_3)+dxdt(k_4));

    x_k(:,:,i) = [k_1, k_2, k_3, k_4];

M = @(x) [-sigma, sigma, 0;
    (rho-x(3)), -1, -x(1);
    x(2), x(1), -beta];

a = M(x)
end


